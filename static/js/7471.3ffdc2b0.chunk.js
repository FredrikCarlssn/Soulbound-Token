"use strict";(self.webpackChunkreact_frontend=self.webpackChunkreact_frontend||[]).push([[7471],{97471:(t,r,a)=>{a.d(r,{h:()=>F,i:()=>z});var e=a(64572),i=a(83374),n=a(2257),s=a(68624),c=a(84530),o=a(65054),p=a(6222),d=a(23425),h=a(90824),l=a(95836),u=a(14026),m=a(67685),g=a(27588),y=a(10917),W=a(12083),w=a(18281),T=a(470),f=a(44554),C=a(14558),v=a(60874),k=a(7339);class S{constructor(t,r,a){(0,e.Z)(this,"featureName",h.cM.name),(0,e.Z)(this,"to",(0,m.c)((async(t,r)=>{const[a,e]=await Promise.all([(0,d.u)(r,this.storage),(0,h.aP)(t)]),i=new W.C(this.contractWrapper),n=a.map((t=>i.encode("mintTo",[e,t])));return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:t=>{const a=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===a.length||a.length<r.length)throw new Error("TokenMinted event not found, minting failed");return a.map((r=>{const a=r.args.tokenIdMinted;return{id:a,receipt:t,data:()=>this.erc721.get(a)}}))}})}))),this.erc721=t,this.contractWrapper=r,this.storage=a}}class b{constructor(t,r,a){(0,e.Z)(this,"featureName",h.cN.name),(0,e.Z)(this,"to",(0,m.c)((async(t,r,a)=>{const e=await this.conditions.getClaimTransaction(t,r,a);return e.setParse((t=>{const a=this.contractWrapper.parseLogs("TokensClaimed",null===t||void 0===t?void 0:t.logs)[0].args.startTokenId,e=a.add(r),i=[];for(let r=a;r.lt(e);r=r.add(1))i.push({id:r,receipt:t,data:()=>this.erc721.get(r)});return i})),e}))),this.erc721=t,this.contractWrapper=r,this.storage=a;const i=new u.C(this.contractWrapper,h.bk,this.storage);this.conditions=new g.D(this.contractWrapper,i,this.storage)}}class P{constructor(t,r){(0,e.Z)(this,"featureName",h.cO.name),(0,e.Z)(this,"to",(0,m.c)((async(t,r,a)=>{const e=await this.getClaimTransaction(t,r,a);return e.setParse((t=>{const a=this.contractWrapper.parseLogs("TokensClaimed",null===t||void 0===t?void 0:t.logs)[0].args.startTokenId,e=a.add(r),i=[];for(let r=a;r.lt(e);r=r.add(1))i.push({id:r,receipt:t,data:()=>this.erc721.get(r)});return i})),e}))),this.erc721=t,this.contractWrapper=r}async getClaimTransaction(t,r,a){let e={};return a&&a.pricePerToken&&(e=await(0,y.c)(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,r],overrides:e})}}class E{constructor(t,r,a){(0,e.Z)(this,"featureName",h.cP.name),(0,e.Z)(this,"lazyMint",(0,m.c)((async(t,r)=>{const a=await this.erc721.nextTokenIdToMint(),e=await(0,d.u)(t,this.storage,a.toNumber(),r),n=(0,d.g)(e);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,n.endsWith("/")?n:"".concat(n,"/"),i.Y0("")],parse:t=>{const r=this.contractWrapper.parseLogs("TokensLazyMinted",null===t||void 0===t?void 0:t.logs),a=r[0].args.startTokenId,e=r[0].args.endTokenId,i=[];for(let n=a;n.lte(e);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})}))),this.erc721=t,this.contractWrapper=r,this.storage=a,this.revealer=this.detectErc721Revealable()}detectErc721Revealable(){if((0,u.d)(this.contractWrapper,"ERC721Revealable"))return new y.D(this.contractWrapper,this.storage,h.cQ.name,(()=>this.erc721.nextTokenIdToMint()))}}class M{constructor(t,r,a){(0,e.Z)(this,"featureName",h.cR.name),(0,e.Z)(this,"to",(0,m.c)((async(t,r)=>{const[a,e]=await Promise.all([(0,d.b)(r,this.storage),(0,h.aP)(t)]);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[e,a],parse:t=>{const r=this.contractWrapper.parseLogs("Transfer",null===t||void 0===t?void 0:t.logs);if(0===r.length)throw new Error("TransferEvent event not found");const a=r[0].args.tokenId;return{id:a,receipt:t,data:()=>this.erc721.get(a)}}})}))),this.erc721=t,this.contractWrapper=r,this.storage=a,this.batch=this.detectErc721BatchMintable()}async getMintTransaction(t,r){return this.to.prepare(await(0,h.aP)(t),r)}detectErc721BatchMintable(){if((0,u.d)(this.contractWrapper,"ERC721BatchMintable"))return new S(this.erc721,this.contractWrapper,this.storage)}}class I{constructor(t,r){(0,e.Z)(this,"featureName",h.cS.name),this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const t=(null===r||void 0===r?void 0:r.start)||0,e=(null===r||void 0===r?void 0:r.count)||d.D;a=a.slice(t,t+e)}return await Promise.all(a.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const r=await(0,h.aP)(t||await this.contractWrapper.getSignerAddress()),a=await this.contractWrapper.read("balanceOf",[r]),e=Array.from(Array(a.toNumber()).keys());return await Promise.all(e.map((t=>this.contractWrapper.read("tokenOfOwnerByIndex",[r,t]))))}}class Z{constructor(t,r){(0,e.Z)(this,"featureName",h.cT.name),this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const t=(null===r||void 0===r?void 0:r.start)||0,e=(null===r||void 0===r?void 0:r.count)||d.D;a=a.slice(t,t+e)}return await Promise.all(a.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const r=await(0,h.aP)(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[r])}}class R{constructor(t,r){(0,e.Z)(this,"featureName",h.cU.name),this.erc721=t,this.contractWrapper=r,this.owned=this.detectErc721Owned()}async all(t){let r=n.O$.from(0);(0,u.h)("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));const a=n.O$.from((null===t||void 0===t?void 0:t.start)||0).add(r).toNumber(),e=n.O$.from((null===t||void 0===t?void 0:t.count)||d.D).toNumber(),i=await this.erc721.nextTokenIdToMint(),s=Math.min(i.add(r).toNumber(),a+e);return await Promise.all([...Array(s-a).keys()].map((t=>this.erc721.get((a+t).toString()))))}async allOwners(){let t,r=n.O$.from(0);(0,u.h)("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));try{t=await this.erc721.totalClaimedSupply()}catch(i){t=await this.totalCount()}t=t.add(r);const a=[...new Array(t.toNumber()).keys()],e=await Promise.all(a.map((t=>this.erc721.ownerOf(t).catch((()=>s.d)))));return a.map((t=>({tokenId:t,owner:e[t]}))).filter((t=>t.owner!==s.d))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){return(0,u.d)(this.contractWrapper,"ERC721Enumerable")?new I(this.erc721,this.contractWrapper):(0,u.d)(this.contractWrapper,"ERC721AQueryable")?new Z(this.erc721,this.contractWrapper):void 0}}const N=(()=>k.B.extend({tierPriority:v.z.array(v.z.string()),royaltyRecipient:h.bd.default(s.d),royaltyBps:h.cF.default(0),quantity:h.b9.default(1)}))(),A=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class O{constructor(t,r,a){(0,e.Z)(this,"featureName",h.cV.name),(0,e.Z)(this,"createBatchWithTier",(0,m.c)((async(t,r,a)=>{const e=await this.erc721.nextTokenIdToMint(),n=await(0,d.u)(t,this.storage,e.toNumber(),a),s=(0,d.g)(n);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[n.length,s.endsWith("/")?s:"".concat(s,"/"),r,i.Y0("")],parse:t=>{const r=this.contractWrapper.parseLogs("TokensLazyMinted",null===t||void 0===t?void 0:t.logs),a=r[0].args[1],e=r[0].args[2],i=[];for(let n=a;n.lte(e);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})}))),(0,e.Z)(this,"createDelayedRevealBatchWithTier",(0,m.c)((async(t,r,a,e,n)=>{if(!a)throw new Error("Password is required");const s=await this.storage.uploadBatch([T.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),p=(0,d.g)(s),h=await this.erc721.nextTokenIdToMint(),l=await this.storage.uploadBatch(r.map((t=>T.a.parse(t))),{onProgress:null===n||void 0===n?void 0:n.onProgress,rewriteFileNames:{fileStartNumber:h.toNumber()}}),u=(0,d.g)(l),g=await this.contractWrapper.read("getBaseURICount",[]),y=await this.contractWrapper.getChainID(),W=c.keccak256(["string","uint256","uint256","address"],[a,y,g,this.contractWrapper.address]),w=await this.contractWrapper.read("encryptDecrypt",[i.Y0(u),W]),f=c.keccak256(["bytes","bytes","uint256"],[i.Y0(u),W,y]),C=o.$.encode(["bytes","bytes32"],[w,f]);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,p.endsWith("/")?p:"".concat(p,"/"),e,C],parse:t=>{const r=this.contractWrapper.parseLogs("TokensLazyMinted",null===t||void 0===t?void 0:t.logs),a=r[0].args[1],e=r[0].args[2],i=[];for(let n=a;n.lte(e);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc721.getTokenMetadata(n)});return i}})}))),(0,e.Z)(this,"reveal",(0,m.c)((async(t,r)=>{if(!r)throw new Error("Password is required");const a=await this.contractWrapper.getChainID(),e=c.keccak256(["string","uint256","uint256","address"],[r,a,t,this.contractWrapper.address]);try{const r=await this.contractWrapper.callStatic().reveal(t,e);if(!r.includes("://")||!r.endsWith("/"))throw new Error("invalid password")}catch(i){throw new Error("invalid password")}return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}))),this.erc721=t,this.contractWrapper=r,this.storage=a}async getMetadataInTier(t){const r=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find((r=>r.tier===t));if(!r)throw new Error("Tier not found in contract.");return await Promise.all(r.ranges.map(((t,a)=>{const e=[],i=r.baseURIs[a];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++){const t=i.endsWith("/")?"".concat(i).concat(r):"".concat(i,"/").concat(r),a=this.storage.downloadJSON(t);e.push(a)}return e})).flat())}async getTokensInTier(t){const r=await this.contractWrapper.read("getTokensInTierLen",[]);if(r.eq(0))return[];const a=await this.contractWrapper.read("getTokensInTier",[t,0,r]);return await Promise.all(a.map((t=>{const r=[];for(let a=t.startIdInclusive.toNumber();a<t.endIdNonInclusive.toNumber();a++)r.push(this.erc721.get(a));return r})).flat())}async generate(t){const[r]=await this.generateBatch([t]);return r}async generateBatch(t){const r=await Promise.all(t.map((t=>N.parseAsync(t)))),a=await this.contractWrapper.getChainID(),e=this.contractWrapper.getSigner();return(0,f.Z)(e,"No signer available"),await Promise.all(r.map((async t=>({payload:t,signature:(await this.contractWrapper.signTypedData(e,{name:"SignatureAction",version:"1",chainId:a,verifyingContract:this.contractWrapper.address},{GenericRequest:A},await this.mapPayloadToContractStruct(t))).toString()}))))}async verify(t){const r=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[r,t.signature]))[0]}async claimWithSignature(t){const r=await this.mapPayloadToContractStruct(t.payload),a=await(0,C.n)(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),e=await this.contractWrapper.getCallOverrides();await(0,T.s)(this.contractWrapper,a,t.payload.currencyAddress,e);const i=await this.contractWrapper.sendTransaction("claimWithSignature",[r,t.signature],e),n=this.contractWrapper.parseLogs("TokensClaimed",null===i||void 0===i?void 0:i.logs),s=n[0].args.startTokenId,c=s.add(n[0].args.quantityClaimed),o=[];for(let p=s;p.lt(c);p=p.add(1))o.push({id:p,receipt:i,data:()=>this.erc721.get(p)});return o}async mapPayloadToContractStruct(t){const r=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),a=o.$.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,r,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:a}}}class L{constructor(t){(0,e.Z)(this,"featureName",h.cW.name),(0,e.Z)(this,"token",(0,m.c)((async t=>m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]})))),this.contractWrapper=t}}class B{constructor(t,r){(0,e.Z)(this,"featureName",h.cX.name),(0,e.Z)(this,"to",(0,m.c)((async(t,r,a)=>{var e;if(t!==await(null===(e=this.contractWrapper.getSigner())||void 0===e?void 0:e.getAddress()))throw new Error("Zora Drop: Destination address must match connected wallet address");if(null!==a&&void 0!==a&&a.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const i=(await this.getSaleDetails()).publicSalePrice,s=(c="0.000777",p.parseEther(h.cz.parse(c)));var c;const o=n.O$.from(i).add(s).mul(r),d=m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[r],overrides:{value:o}});return d.setParse((t=>{const a=this.contractWrapper.parseLogs("Sale",null===t||void 0===t?void 0:t.logs)[0].args.firstPurchasedTokenId,e=a.add(r),i=[];for(let r=a;r.lt(e);r=r.add(1))i.push({id:r,receipt:t,data:()=>this.erc721.get(r)});return i})),d}))),this.erc721=t,this.contractWrapper=r}async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class D{constructor(t){(0,e.Z)(this,"featureName",h.cY.name),(0,e.Z)(this,"cancel",(0,m.c)((async t=>m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]})))),(0,e.Z)(this,"revoke",(0,m.c)((async t=>m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]})))),this.contractWrapper=t}}class q{constructor(t,r){(0,e.Z)(this,"featureName",h.cZ.name),(0,e.Z)(this,"update",(0,m.c)((async(t,r)=>{const a=await(0,d.b)(r,this.storage);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,a]})}))),this.contractWrapper=t,this.storage=r}}class x{constructor(t,r){(0,e.Z)(this,"featureName",h.c_.name),(0,e.Z)(this,"set",(0,m.c)((async t=>{const r=T.B.parse(t);r.description=this.sanitizeJSONString(r.description);const a=[];(0,w.XT)(r.image)?a.push(this.storage.upload(r.image)):"string"===typeof r.image?a.push(Promise.resolve(r.image)):a.push(Promise.resolve(void 0)),(0,w.XT)(r.animation_url)?a.push(this.storage.upload(r.animation_url)):"string"===typeof r.animation_url?a.push(Promise.resolve(r.animation_url)):a.push(Promise.resolve(void 0));const[e,i]=await Promise.all(a);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:"".concat(r.name||""),description:r.description||"",imageURI:e||"",animationURI:i||""}]})}))),this.contractWrapper=t,this.storage=r}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every((t=>""===t)))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}sanitizeJSONString(t){if(!t)return t;const r=JSON.stringify(t);return r.slice(1,r.length-1)}}class z{constructor(t,r){(0,e.Z)(this,"featureName",h.c$.name),(0,e.Z)(this,"mint",(0,m.c)((async t=>{const r=t.payload,a=t.signature,e=await this.contractWrapper.getCallOverrides(),i=t=>{const r=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===r.length)throw new Error("No MintWithSignature event found");return{id:r[0].args.tokenIdMinted,receipt:t}};if(await this.isLegacyNFTContract()){const t=await this.mapLegacyPayloadToContractStruct(r),n=t.price;return await(0,T.s)(this.contractWrapper,n,r.currencyAddress,e),m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,a],overrides:e,parse:i})}{const t=await this.mapPayloadToContractStruct(r),n=t.pricePerToken.mul(t.quantity);return await(0,T.s)(this.contractWrapper,n,r.currencyAddress,e),m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,a],overrides:e,parse:i})}}))),(0,e.Z)(this,"mintBatch",(0,m.c)((async t=>{const r=await this.isLegacyNFTContract(),a=(await Promise.all(t.map((t=>r?this.mapLegacyPayloadToContractStruct(t.payload):this.mapPayloadToContractStruct(t.payload))))).map(((r,a)=>{const e=t[a],i=e.signature,s=e.payload.price;if(n.O$.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:r,signature:i}})),e=new W.C(this.contractWrapper),i=a.map((t=>e.encode("mintWithSignature",[t.message,t.signature])));if((0,u.h)("multicall",this.contractWrapper))return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i],parse:t=>{const r=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===r.length)throw new Error("No MintWithSignature event found");return r.map((r=>({id:r.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not available on this contract!")}))),this.contractWrapper=t,this.storage=r}async verify(t){const r=await this.isLegacyNFTContract(),a=t.payload,e=t.signature;let i,n;return r?(i=await this.mapLegacyPayloadToContractStruct(a),n=await this.contractWrapper.read("verify",[i,e])):(i=await this.mapPayloadToContractStruct(a),n=await this.contractWrapper.read("verify",[i,e])),n[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const r=await this.isLegacyNFTContract(),a=await Promise.all(t.map((t=>k.q.parseAsync(t)))),e=a.map((t=>t.metadata)),i=await(0,d.u)(e,this.storage),n=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,f.Z)(s,"No signer available"),await Promise.all(a.map((async(t,a)=>{const e=i[a],c=await k.r.parseAsync({...t,uri:e});let o;return o=r?await this.contractWrapper.signTypedData(s,{name:"TokenERC721",version:"1",chainId:n,verifyingContract:this.contractWrapper.address},{MintRequest:k.s},await this.mapLegacyPayloadToContractStruct(c)):await this.contractWrapper.signTypedData(s,{name:"SignatureMintERC721",version:"1",chainId:n,verifyingContract:await this.contractWrapper.address},{MintRequest:k.u},await this.mapPayloadToContractStruct(c)),{payload:c,signature:o.toString()}})))}async mapPayloadToContractStruct(t){const r=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:r,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const r=await(0,C.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:r,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return(0,u.d)(this.contractWrapper,"ERC721SignatureMintV1")}}class F{get chainId(){return this._chainId}constructor(t,r,a){(0,e.Z)(this,"featureName",h.d0.name),(0,e.Z)(this,"transfer",(0,m.c)((async(t,r)=>{const[a,e]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,h.aP)(t)]);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[a,e,r]})}))),(0,e.Z)(this,"transferFrom",(0,m.c)((async(t,r,a)=>{const[e,i]=await Promise.all([(0,h.aP)(t),(0,h.aP)(r)]);return m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[e,i,a]})}))),(0,e.Z)(this,"setApprovalForAll",(0,m.c)((async(t,r)=>m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await(0,h.aP)(t),r]})))),(0,e.Z)(this,"setApprovalForToken",(0,m.c)((async(t,r)=>m.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await(0,h.aP)(t),r]})))),(0,e.Z)(this,"mint",(0,m.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)))),(0,e.Z)(this,"mintTo",(0,m.c)((async(t,r)=>(0,l.a)(this.mintable,h.cR).to.prepare(t,r)))),(0,e.Z)(this,"mintBatch",(0,m.c)((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)))),(0,e.Z)(this,"mintBatchTo",(0,m.c)((async(t,r)=>{var a;return(0,l.a)(null===(a=this.mintable)||void 0===a?void 0:a.batch,h.cM).to.prepare(t,r)}))),(0,e.Z)(this,"burn",(0,m.c)((async t=>(0,l.a)(this.burnable,h.cW).token.prepare(t)))),(0,e.Z)(this,"cancel",(0,m.c)((async t=>(0,l.a)(this.loyaltyCard,h.cY).cancel.prepare(t)))),(0,e.Z)(this,"revoke",(0,m.c)((async t=>(0,l.a)(this.loyaltyCard,h.cY).revoke.prepare(t)))),(0,e.Z)(this,"lazyMint",(0,m.c)((async(t,r)=>(0,l.a)(this.lazyMintable,h.cP).lazyMint.prepare(t,r)))),(0,e.Z)(this,"update",(0,m.c)((async(t,r)=>(0,l.a)(this.updatableMetadata,h.cZ).update.prepare(t,r)))),(0,e.Z)(this,"claim",(0,m.c)((async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r)))),(0,e.Z)(this,"claimTo",(0,m.c)((async(t,r,a)=>{const e=this.claimWithConditions,i=this.claimCustom,n=this.claimZora;if(e)return e.to.prepare(t,r,a);if(i)return i.to.prepare(t,r,a);if(n)return n.to.prepare(t,r,a);throw new h.x(h.cO)}))),this.contractWrapper=t,this.storage=r,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[r,a]=await Promise.all([this.ownerOf(t).catch((()=>s.d)),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...d.F})))]);return{owner:r,metadata:a,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await(0,h.aP)(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,r){const[a,e]=await Promise.all([(0,h.aP)(t),(0,h.aP)(r)]);return await this.contractWrapper.read("isApprovedForAll",[a,e])}async getAll(t){return(0,l.a)(this.query,h.cU).all(t)}async getAllOwners(){return(0,l.a)(this.query,h.cU).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return(0,l.a)(this.query,h.cU).totalCirculatingSupply()}async getOwned(t,r){var a;if(t&&(t=await(0,h.aP)(t)),null!==(a=this.query)&&void 0!==a&&a.owned)return this.query.owned.all(t,r);{const[a,e]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);let i=(e||[]).filter((t=>{var r;return(null===a||void 0===a?void 0:a.toLowerCase())===(null===(r=t.owner)||void 0===r?void 0:r.toLowerCase())}));if(r){const t=(null===r||void 0===r?void 0:r.start)||0,a=(null===r||void 0===r?void 0:r.count)||d.D;i=i.slice(t,t+a)}return await Promise.all(i.map((async t=>this.get(t.tokenId))))}}async getOwnedTokenIds(t){var r;if(t&&(t=await(0,h.aP)(t)),null!==(r=this.query)&&void 0!==r&&r.owned)return this.query.owned.tokenIds(t);{const[r,a]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(a||[]).filter((t=>{var a;return(null===r||void 0===r?void 0:r.toLowerCase())===(null===(a=t.owner)||void 0===a?void 0:a.toLowerCase())})).map((t=>n.O$.from(t.tokenId)))}}async getMintTransaction(t,r){return this.mintTo.prepare(t,r)}async getClaimTransaction(t,r,a){const e=this.claimWithConditions,i=this.claimCustom;if(e)return e.conditions.getClaimTransaction(t,r,a);if(i)return i.getClaimTransaction(t,r,a);throw new h.x(h.cO)}async totalClaimedSupply(){const t=this.contractWrapper;if((0,u.h)("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if((0,u.h)("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,r]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(r)}get claimConditions(){return(0,l.a)(this.claimWithConditions,h.cN).conditions}get tieredDrop(){return(0,l.a)(this.tieredDropable,h.cV)}get signature(){return(0,l.a)(this.signatureMintable,h.c$)}get revealer(){var t;return(0,l.a)(null===(t=this.lazyMintable)||void 0===t?void 0:t.revealer,h.cQ)}get sharedMetadata(){return(0,l.a)(this.erc721SharedMetadata,h.c_)}async getTokenMetadata(t){const r=await this.contractWrapper.read("tokenURI",[t]);if(!r)throw new h.n;return(0,d.f)(t,r,this.storage)}async nextTokenIdToMint(){if((0,u.h)("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return(0,u.h)("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}if((0,u.h)("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if((0,u.d)(this.contractWrapper,"ERC721Supply")||(0,u.h)("nextTokenIdToMint",this.contractWrapper))return new R(this,this.contractWrapper)}detectErc721Mintable(){if((0,u.d)(this.contractWrapper,"ERC721Mintable"))return new M(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if((0,u.d)(this.contractWrapper,"ERC721Burnable"))return new L(this.contractWrapper)}detectErc721LazyMintable(){if((0,u.d)(this.contractWrapper,"ERC721LazyMintable"))return new E(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if((0,u.d)(this.contractWrapper,"ERC721TieredDrop"))return new O(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if((0,u.d)(this.contractWrapper,"ERC721SignatureMintV1")||(0,u.d)(this.contractWrapper,"ERC721SignatureMintV2"))return new z(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if((0,u.d)(this.contractWrapper,"ERC721ClaimConditionsV1")||(0,u.d)(this.contractWrapper,"ERC721ClaimConditionsV2")||(0,u.d)(this.contractWrapper,"ERC721ClaimPhasesV1")||(0,u.d)(this.contractWrapper,"ERC721ClaimPhasesV2"))return new b(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if((0,u.d)(this.contractWrapper,"ERC721ClaimCustom"))return new P(this,this.contractWrapper)}detectErc721ClaimableZora(){if((0,u.d)(this.contractWrapper,"ERC721ClaimZora"))return new B(this,this.contractWrapper)}detectErc721SharedMetadata(){if((0,u.d)(this.contractWrapper,"ERC721SharedMetadata"))return new x(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if((0,u.d)(this.contractWrapper,"ERC721LoyaltyCard"))return new D(this.contractWrapper)}detectErc721UpdatableMetadata(){if((0,u.d)(this.contractWrapper,"ERC721UpdatableMetadata"))return new q(this.contractWrapper,this.storage)}}}}]);
//# sourceMappingURL=7471.3ffdc2b0.chunk.js.map